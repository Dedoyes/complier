//**********************int********************
// int a;
// int a,b,c;
// int a = 1;
// int a = 1 , b = 2 , c = 3;
 // int a = 1 + (2+3);

生成四元式序列：
// ( declare , _ , _ , a)

// ( declare , _ , _ , a)
// ( declare , _ , _ , b)
// ( declare , _ , _ , c)


// ( declare , _ , _ , a)
// ( = , 1 , _ , a )
// ( declare , _ , _ , b)
// ( = , 2, _ , b )
// ( declare , _ , _ , c)
// ( = , 3 , _ , c )


int main() {
    // ...
    return 0;
}
1. (main_start, main, -, -)  // 主函数开始标记 main_end
2. (return_type, -, -, int)      // 声明主函数返回类型为int//*********************************************
3. (main_end, main, -, -)    // 主函数结束标记  cseg ends end start


int add(int x, int y) {
    int result = x + y;
    return result;
}
//四元式表示
1. (function_begin, int , -,add)   // 函数add开始标记 
3. (param, -, -, x)              // 声明参数x
4. (param, -, -, y)              // 声明参数y
5. (declare, -, -, result)       // 声明局部变量result///局部变量 数据段里
6. (+, x, y, T1)                 // 计算x + y，结果存入临时变量T1
7. (=, T1, -, result)            // 将T1的值赋给result
8. (return, result, -, -)        // 返回result的值
9. (function_end, add, -, -)     // 函数add结束标记

//*******************************************赋值语句****************************************

(+, A, B, T1)  // 将A和B相加，结果存入临时变量T1 
(-, C, D, T2)  // 将C减去D，结果存入临时变量T2
(*, E, F, T3)  // 将E和F相乘，结果存入临时变量T3
(/, G, H, T4)  // 将G除以H，结果存入临时变量T4


//********************************************if**********************************************


if (A&&B&&(C>D)){

	if(A < B) break;
	else F=1;
}
else if(!A||!B) G= G-1;
else G = G + 1

// 外层条件部分
(JUMP_FALSE, A, , L1)
(JUMP_FALSE, B, , L1)
(>, C, D, t0)
(JUMP_FALSE, t0, , L1)

// 内层 if-else 结构
(<, A, B, t1)
(JUMP_FALSE, t1, , L2)
(BREAK, , , )
(JUMP, , , L3)
(LABEL, , , L2)
(=, 1, , F)
(LABEL, , , L3)
(JUMP, , , L4)

// 外层 else if 结构
(JUMP_FALSE, !A, , L5)
(JUMP, , , L6)
(LABEL, , , L5)
(JUMP_FALSE, !B, , L1)
(LABEL, , , L6)
(-, G, 1, t2)
(=, t2, , G)
(JUMP, , , L4)

// 外层 else 结构
(LABEL, , , L1)
(+, G, 1, t3)
(=, t3, , G)

// 结束标签
(LABEL, , , L4)

if (A&&B&&(C>D)){

	if(A>B)break;
	else continue;
}
else G = G + 1

// 外层条件部分
(JUMP_FALSE, A, , L1)
(JUMP_FALSE, B, , L1)
(>, C, D, t0)
(JUMP_FALSE, t0, , L1)

// 内层 if-else 结构
(>, A, B, t1)
(JUMP_FALSE, t1, , L2)
(BREAK, , , )
(JUMP, , , L3)
(LABEL, , , L2)
(CONTINUE, , , )
(JUMP, , , L3)
(LABEL, , , L3)
(JUMP, , , L4)

// 外层 else 结构
(LABEL, , , L1)
(+, G, 1, t2)
(=, t2, , G)

// 结束标签
(LABEL, , , L4)

//**************************************for语句******************************

for(int i = a+b*2;i<=c+d+10;i++){
	if(h>g) p=p+1;
}

// 初始化部分
(*, b, 2, t0)
(+, a, t0, i)

// 条件检查部分
(LABEL, , , L0)
(+, c, d, t1)
(+, t1, 10, t2)
(<=, i, t2, t3)
(JUMP_FALSE, t3, , L1)

// 循环体部分
(>, h, g, t4)
(JUMP_FALSE, t4, , L2)
(+, p, 1, t5)
(=, t5, , p)
(LABEL, , , L2)

// 增量部分
(+, i, 1, t6)
(=, t6, , i)
(JUMP, , , L0)

// 循环结束
(LABEL, , , L1)

//*************************************while********************************

// 条件检查部分
(LABEL, , , L0)
(+, c, d, t0)
(+, t0, 10, t1)
(<=, i, t1, t2)
(JUMP_FALSE, t2, , L1)

// 循环体部分
(+, i, 1, t3)
(=, t3, , i)
(+, p, 1, t4)
(=, t4, , p)

// 跳转回条件检查位置
(JUMP, , , L0)

// 循环结束
(LABEL, , , L1)


//************************************struct********************************

struct Point {
    int x;
    int y;
};

struct Point p1;
p1.x = 5;
p1.y = 10;

if (p1.x > p1.y) {
    p1.x = p1.x + 1;
} else {
    p1.y = p1.y + 1;
}

// 结构体声明部分
(STRUCT, , , Point)
(DECL, int, , Point.x)
(DECL, int, , Point.y)

// 变量声明部分
(DECL, struct Point, , p1)

// 变量赋值部分
(=, 5, , p1.x)
(=, 10, , p1.y)

// 条件部分
(>, p1.x, p1.y, t1)
(JUMP_FALSE, t1, , L1)

// 条件为真时的操作部分
(+, p1.x, 1, t2)
(=, t2, , p1.x)
(JUMP, , , L2)

// 条件为假时的操作部分
(LABEL, , , L1)
(+, p1.y, 1, t3)
(=, t3, , p1.y)

// 条件结束部分
(LABEL, , , L2)

/////////////////////////////////////struct转为汇编 ？？？ 需要自己设计
section .data
    p1_x dw 0
    p1_y dw 0

section .code
    ; 初始化 p1.x = 5
    mov ax, 5
    mov [p1_x], ax

    ; 初始化 p1.y = 10
    mov ax, 10
    mov [p1_y], ax

    ; 条件判断: if (p1.x > p1.y)
    mov ax, [p1_x]
    cmp ax, [p1_y]
    jle ELSE_PART

    ; if 部分: p1.x = p1.x + 1
    mov ax, [p1_x]
    add ax, 1
    mov [p1_x], ax
    jmp END_IF

ELSE_PART:
    ; else 部分: p1.y = p1.y + 1
    mov ax, [p1_y]
    add ax, 1
    mov [p1_y], ax

END_IF:
    ; 程序结束标记（如果需要）
    nop
//***************************************************样例 仅供参考







(DECL, int, , a)
(=, 5, , a)
(DECL, int, , b)
(=, 10, , b)
(=, 3.14, , f)
(DECL, int, , c)
(DECL, int, , d)
(DECL, int, , =)
(DECL, int, , 20)
(FUNC, int, , sum)
(PARAM, int, , x)
(PARAM, int, , y)
(+, x, y, t0)
(IF, a, b, t1)
(=, a, , a)
(-, a, b, t2)
(FOR, int, i, 0)
(IF, i, 10, t3)
(i, ;, , )
(END_FOR, , , )
(=, a, , a)
(+, a, i, t4)
(FUNC, int, , main)
(=, 10, , x)
(=, 20, , y)
(=, sum, , c)
(STRUCT, , , Point)
(DECL, int, , x)
(DECL, int, , y)

二：
 token:
       {"int", 1}, {"main", 12}, {"(", 8}, {")", 9}, {"{", 10},
        {"int", 1}, {"a", 1}, {",", 5}, {"b", 1}, {",", 5}, {"c", 1}, {";", 7},
        {"a", 1}, {"=", 24}, {"b", 1}, {"*", 3}, {"(", 8}, {"1", 1}, {"+", 1}, {"d", 1}, {"*", 3}, {"(", 8}, {"2", 1}, {"+", 1}, {"3", 1}, {")", 9}, {")", 9}, {";", 7},
        {"return", 13}, {"0", 1}, {";", 7}, {"}", 11}

qua:
(FUNC, int, , main)
(DECL, int, , a)
(DECL, int, , b)
(DECL, int, , c)
(+, 2, 3, t0)
(*, d, t0, t1)
(+, 1, t1, t2)
(*, b, t2, t3)
(=, t3, , a)
(RETURN, , , 0)
(END_FUNC, , , main)
